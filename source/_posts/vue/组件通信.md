---
title: 组件通信
tags: Vue
categories: Vue 探索与实践
abbrlink: 42732
date: 2018-07-09 22:31:06
---

Vue最核心的内容就是数据驱动，完整的掌握组件之间的数据流动方式，在不同的场景下使用不同的方式，尤为重要。组件通信从Vue1.0开始使用 dispatch与events事件对象来进行数据通信， vue2.0简化了api组件间的数据传递有了很多种形式其中一个就是 v-model。

#### $on $emit v-on

> 组件之间的数据传递与改变需要动作，所谓的动作就好比大家在一起玩丢手绢。我扔给你，你丢给我。动作即事件

`$on` , `$emit` 用于自定义事件的监听与触发。

`v-on` 与 `$emit` 父组件在引入子组件的时用于监听子组件的 `$emit` 自定义事件

```html
<div id="app">
    <child></child>
</div>
<script>
    Vue.component('child', {
        template: `<div>
                     <button @click='handel1'>派发事件1</button>
                     <button @click='handel2'>派发事件2</button>
                  </div>`,
        created() {
            this.$on('eat', (arg)=> {
                console.log(arg)
            })

            this.$on('run', (arg)=> {
                console.log(arg)
            })

            // 数组特性 可以接受多个派发事件 
            this.$on(['eat', 'run'], (args)=> {
                console.log(args)
            })
        },  
        methods: {
            handel1() {
                this.$emit('eat', '吃饭')
            },
            handel2() {
                this.$emit('run', '跑步')
            }
        }
    })

    new Vue({
        el: '#app'
    })
</script>
```

上面这种做法实际中没有太大意义，通常都是 `$emit` 自定义的事件在父级中进行触发

```html
<div id="app">
    <child @eat='foo' @run='bar'></child>
</div>
<script>
    Vue.component('child', {
        template: `<div>
                     <button @click='handel1'>派发事件1</button>
                     <button @click='handel2'>派发事件2</button>
                  </div>`,
        methods: {
            handel1() {
                this.$emit('eat', '吃饭')
            },
            handel2() {
                this.$emit('run', '跑步')
            }
        }
    })

    new Vue({
        el: '#app',
        methods: {
            foo(arg) {
                console.log(arg)
            },
            bar(arg) {
                console.log(arg)
            }
        }
    })
</script>
```

> 注意点：$on，$emit只能作用于同一个组件实例，$on不能侦听子组件事件的释放。需要使用v-on（@）作用在组件引入的模板上来侦听子组件的事件释放。

数据传递 官方有一个案例

```html
<div id="counter-event-example">
  <p>{{ total }}</p>
  <button-counter v-on:increment="incrementTotal"></button-counter>
  <button-counter v-on:increment="incrementTotal"></button-counter>
</div>
<script>
Vue.component('button-counter', {
  template: '<button v-on:click="incrementCounter">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    incrementCounter: function () {
      this.counter += 1
      this.$emit('increment')
    }
  },
})
new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
</script>
```

上面操作是为了可以对每一个组件进行一个计数的功能，每一个子组件有自己独立的 `counter` 累加值，通过触发父组件中事件使 total 进行改变

但是如果仅仅是为了传递数据，不需要改变父组件中数据的状态则不需要这么麻烦。vue2.0对数据的流向进行了限制，子组件数据的改变不应该直接影响父组件，需要通过一些手段

```html
<div id="app">
    <child :msg=msg @change='handel'></child>
</div>
<script>
    Vue.component('child', {
        props: ['msg'],
        template: `<div @click='changeText'>
                     {{msg}}
                  </div>`,
        methods: {
            changeText() {
                this.$emit('change', '数据改变通知父组件改变')
            }
        }
    })

    new Vue({
        el: '#app',
        data: {
            msg: '数据没有改变'
        },
        methods: {
            handel(val) {
                this.msg = val
            }
        }
    })
</script>
```

看着好像很复杂其实在官网的api提供了更加简便的操作。始终记得数据是单向流动的。仅仅要使用传递的数据但是不想改变，官网希望在子组件中定义data存储传递的props。

#### v-model

通过官网的案例了解一下

```html
<div id="app">
    <custom-input v-model="searchText"></custom-input>
    {{searchText}}
</div>
<script>
Vue.component('custom-input', {
  props: ['value'],
  template: `
    <input
      v-bind:value="value"
      v-on:input="$emit('input', $event.target.value)"
    >
  `
})
new Vue({
    el: '#app',
    data: {
        searchText: 'search'
    }
})
</script>
```

> 注意：为了让它正常工作，这个组件内的 `<input>` 必须 
>
> 将其 `value` 特性绑定到一个名叫 `value` 的 prop 上
>
> 在其 `input` 事件被触发时，将新的值通过自定义的 `input` 事件抛出

` v-model` 相当于在组件上添加了 `:value=searchText` `@input="searchText = $event.target.value"` 算是一个简化api的功能，用在 *input* 标签上 `v-mode` 会自动的去监听 `oninput` 事件并改变数据。同理表单的其它type都可以使用 `v-model` 这个功能。

```html
<input type="checkbox" :checked="status" @change="status = $event.target.checked">
<input type="radio" :checked="status" @change="status = $event.target.checked">
```

v-model在组件的使用就这么简单吗？有哪些坑，看一个有冲突的错误案例

```html
<div id="app">
    <button @click="show=true">打开model</button>
    <model v-model="show"></model>
</div>
<script>
    Vue.component('model', {
        props: ['value'],
        template: `<div v-show="value">
                      <div>
                         <p>这是一个Model框</p>
                        <input type="text" v-model="value">
                        {{value}}
                         <button @click="close">关闭</button>
                      </div>
                   </div>`,
        methods: {
            close() {
                this.$emit('input', false)
            }
        }
    })

    new Vue({
        el: '#app',
        data: {
            show: false
        }
    })
</script>
```

首先注意一下在组件模板上使用了 `v-model` 让数据传递简化，同时在组件内部的 input同样使用了 `v-model` 正常打开关闭都可以，但是当把input里边的值删除的时候会发现model框自动关闭了...wtf！！

可以看出来组件内部的 `v-model` 与模板上的公用了同一个 value，并且$emit事件也是同一个发生了冲突，看控制台可以看到错误，因为内部的尝试改变了父组件数据。

自定义组件的 v-model

```html
<div id="app">
    <button @click='show=true'>打开</button>
    <model v-model='show'></model>
</div>
<script>
    Vue.component('model', {
        model: {
            prop: 'flag',
            event: 'close'
        },
        props: ['flag'],
        data() {
            return {
                value: this.flag
            }
        },
        template: `<div v-show='flag'>
                    <p>这是一个model框</p>
                    <input type="text" v-model='value'>
                    <button @click='close'>close model</button>
                </div>`,
        methods: {
            close() {
                this.$emit('close', false)
            }
        }
    })

    new Vue({
        el: '#app',
        data: {
            show: false
        }
    })
</script>
```

这样子就不会和组件内部的 v-model冲突了，因为v-model都是默认 `value` 属性和 `input` 事件

看完这个就可以自定义一些表单组件

```js
Vue.component('base-checkbox', {
  model: {
    prop: 'checked',
    event: 'change'
  },
  props: {
    checked: Boolean
  },
  template: `
    <input
      type="checkbox"
      :checked="checked"
      @change="$emit('change', $event.target.checked)"
    >
  `
})
```

#### .sync 归来

从 `v-model` 到 `.sync` 其实都是 $emit 与 v-on的语法糖

```html
<demo v-model='value'></demo>
<demo v-bind='value' v-on:input='handel'></demo>
handel(ev){ this.$emit(ev.target.value) }
```

```html
<demo :value.sync='val'></demo>
<demo :value='val' v-on:update:value='arg => val=arg'></demo>
更改的时候显式触发事件
this.$emit('update:value', newValue)
```

看了这个model框就可以改变一下了

```html
<div id="app">
    <button @click='flag=true'>打开</button>
    <model :show.sync='flag'></model>
</div>
<script>
    Vue.component('model', {
        props: ['show'],
        template: `<div v-show='show'>
                    <p>这是一个model框</p>
                    <button @click='close'>close model</button>
                </div>`,
        methods: {
            close() {
                this.$emit('update:show', false)
            }
        }
    })

    new Vue({
        el: '#app',
        data: {
            flag: false
        }
    })
</script>
```

> 注意：子组件改变父组件的数据时，update 冒号后面的参数和父组件传递进来的值是同步的，两者一一对应。

仿佛打开了新世界的大门，对于单个或者多个数据双向绑定的操作 `v-mode` 和 `.sync` 还是可以轻松胜任的。但是如果在深层次的数据传递过程中应该使用什么方式？

#### $listener $attrs

#### bus